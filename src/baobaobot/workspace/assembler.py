"""CLAUDE.md assembly — composes the workspace CLAUDE.md from shared files.

Reads AGENTS.md and AGENTSOUL.md from shared_dir, then writes a single
assembled CLAUDE.md in the workspace root.  A dynamic "Memory Context"
section lists available experience/ topic files so Claude Code knows what
long-term memory exists.  Daily memories are NOT embedded — Claude Code
reads those on demand via skills (memory-list, memory-search).

Key class: ClaudeMdAssembler.
"""

import logging
from datetime import datetime
from pathlib import Path

from baobaobot.memory.utils import strip_frontmatter


logger = logging.getLogger(__name__)

# Section order in the assembled CLAUDE.md
# (filename, section_title, source)  — source is "shared" or "workspace"
_SECTION_ORDER = [
    ("AGENTS.md", "Work Instructions (AGENTS)", "shared"),
    ("AGENTSOUL.md", "Agent Soul (AGENTSOUL)", "shared"),
]

_HEADER = """\
# BaoBao Assistant

> This file is auto-generated by BaoBaoClaude. Do not edit manually.
> Last updated: {timestamp}
"""


class ClaudeMdAssembler:
    """Reads shared persona files, assembles CLAUDE.md."""

    def __init__(
        self, shared_dir: Path, workspace_dir: Path, locale: str = "en-US"
    ) -> None:
        self.shared_dir = shared_dir
        self.workspace_dir = workspace_dir
        self.locale = locale
        self.output_path = workspace_dir / "CLAUDE.md"
        self._source_mtimes: dict[str, float] = {}

    def _read_file(self, path: Path) -> str:
        """Read a file, stripping frontmatter, returning empty string if missing."""
        try:
            content = path.read_text(encoding="utf-8").strip()
            return strip_frontmatter(content).strip()
        except OSError:
            return ""

    def _resolve_source_dir(self, source: str) -> Path:
        """Return shared_dir or workspace_dir based on source tag."""
        return self.shared_dir if source == "shared" else self.workspace_dir

    def _experience_listing(self) -> str:
        """Generate a listing of memory/experience/ topic files."""
        exp_dir = self.workspace_dir / "memory" / "experience"
        if not exp_dir.is_dir():
            return ""
        files = sorted(f.stem for f in exp_dir.glob("*.md"))
        if not files:
            return ""
        lines = ["### Experience Topics (Long-term Memory)\n"]
        for name in files:
            lines.append(f"- `{name}` → memory/experience/{name}.md")
        return "\n".join(lines)

    def _resolve_agentsoul_path(self) -> Path:
        """Return workspace-local AGENTSOUL.md if it exists, else shared."""
        local = self.workspace_dir / ".persona" / "AGENTSOUL.md"
        if local.is_file():
            return local
        return self.shared_dir / "AGENTSOUL.md"

    def assemble(self) -> str:
        """Build the full CLAUDE.md content from source files."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        parts: list[str] = [_HEADER.format(timestamp=timestamp)]

        for filename, section_title, source in _SECTION_ORDER:
            if filename == "AGENTSOUL.md":
                filepath = self._resolve_agentsoul_path()
            else:
                source_dir = self._resolve_source_dir(source)
                filepath = source_dir / filename
            content = self._read_file(filepath)
            if content:
                parts.append(f"---\n\n## {section_title}")
                parts.append(content)

        # Dynamic memory context: list experience topic files
        exp_listing = self._experience_listing()
        if exp_listing:
            parts.append(f"---\n\n## Memory Context\n\n{exp_listing}")

        result = "\n\n".join(parts) + "\n"
        # Replace template variables (safety net for old AGENTS.md with {{BIN_DIR}})
        result = result.replace("{{BIN_DIR}}", str(self.shared_dir / "bin"))
        result = result.replace("{{USERS_DIR}}", str(self.shared_dir / "users"))
        result = result.replace("{{WORKSPACE_DIR}}", str(self.workspace_dir))
        result = result.replace("{{LOCALE}}", self.locale)
        return result

    def write(self) -> None:
        """Assemble and write CLAUDE.md to the workspace root."""
        content = self.assemble()
        self.output_path.write_text(content, encoding="utf-8")
        logger.info("Assembled CLAUDE.md at %s", self.output_path)

        # Clean up legacy BAOBAOBOT.md if present
        legacy = self.workspace_dir / "BAOBAOBOT.md"
        if legacy.exists():
            legacy.unlink()
            logger.info("Removed legacy BAOBAOBOT.md from %s", self.workspace_dir)

        # Update mtime cache
        self._update_mtimes()

    def _update_mtimes(self) -> None:
        """Cache modification times of source files and experience dir."""
        self._source_mtimes = {}
        for filename, _, source in _SECTION_ORDER:
            if filename == "AGENTSOUL.md":
                # Track both local (.persona/) and shared paths
                local = self.workspace_dir / ".persona" / "AGENTSOUL.md"
                shared = self.shared_dir / "AGENTSOUL.md"
                if local.exists():
                    self._source_mtimes["local:AGENTSOUL.md"] = local.stat().st_mtime
                self._source_mtimes["local:AGENTSOUL.md:exists"] = (
                    1.0 if local.exists() else 0.0
                )
                if shared.exists():
                    self._source_mtimes["shared:AGENTSOUL.md"] = shared.stat().st_mtime
            else:
                source_dir = self._resolve_source_dir(source)
                filepath = source_dir / filename
                if filepath.exists():
                    self._source_mtimes[f"{source}:{filename}"] = (
                        filepath.stat().st_mtime
                    )

        # Track experience directory (mtime changes when files added/removed)
        exp_dir = self.workspace_dir / "memory" / "experience"
        if exp_dir.is_dir():
            self._source_mtimes["experience_dir"] = exp_dir.stat().st_mtime

    def needs_rebuild(self) -> bool:
        """Check if any source file or experience dir has changed since last assembly."""
        if not self.output_path.exists():
            return True

        if not self._source_mtimes:
            # No cached mtimes — need rebuild
            return True

        for filename, _, source in _SECTION_ORDER:
            if filename == "AGENTSOUL.md":
                local = self.workspace_dir / ".persona" / "AGENTSOUL.md"
                shared = self.shared_dir / "AGENTSOUL.md"
                local_exists = local.exists()
                cached_exists = (
                    self._source_mtimes.get("local:AGENTSOUL.md:exists", 0.0) == 1.0
                )

                # Local created or deleted → rebuild
                if local_exists != cached_exists:
                    return True

                if local_exists:
                    # Local is authoritative — only check local mtime
                    current = local.stat().st_mtime
                    cached = self._source_mtimes.get("local:AGENTSOUL.md", 0)
                    if current > cached:
                        return True
                else:
                    # No local — check shared
                    if shared.exists():
                        current = shared.stat().st_mtime
                        cached = self._source_mtimes.get("shared:AGENTSOUL.md", 0)
                        if current > cached:
                            return True
            else:
                source_dir = self._resolve_source_dir(source)
                filepath = source_dir / filename
                if filepath.exists():
                    current_mtime = filepath.stat().st_mtime
                    cached = self._source_mtimes.get(f"{source}:{filename}", 0)
                    if current_mtime > cached:
                        return True

        # Check experience directory for added/removed files
        exp_dir = self.workspace_dir / "memory" / "experience"
        if exp_dir.is_dir():
            current_mtime = exp_dir.stat().st_mtime
            cached = self._source_mtimes.get("experience_dir", 0)
            if current_mtime > cached:
                return True

        return False


def rebuild_all_workspaces(
    shared_dir: Path, workspace_dirs: list[Path], locale: str = "en-US"
) -> int:
    """Rebuild CLAUDE.md for all workspaces where sources have changed.

    Returns the number of workspaces rebuilt.
    """
    rebuilt = 0
    for ws in workspace_dirs:
        assembler = ClaudeMdAssembler(shared_dir, ws, locale=locale)
        if assembler.needs_rebuild():
            assembler.write()
            rebuilt += 1
    return rebuilt

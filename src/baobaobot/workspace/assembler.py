"""CLAUDE.md assembly — composes the workspace CLAUDE.md from shared files.

Reads AGENTS.md and AGENTSOUL.md from shared_dir, then writes a single
assembled CLAUDE.md in the workspace root.  A dynamic "Memory Context"
section lists available experience/ topic files so Claude Code knows what
long-term memory exists.  User profiles are embedded directly so Claude Code
doesn't need to read them from disk.  Daily memories are NOT embedded —
Claude Code reads those on demand via skills (memory-list, memory-search).

Key class: ClaudeMdAssembler.
"""

import logging
from datetime import datetime
from pathlib import Path

from baobaobot.memory.utils import strip_frontmatter


logger = logging.getLogger(__name__)

# Section order in the assembled CLAUDE.md
# (filename, section_title, source)  — source is "shared" or "workspace"
_SECTION_ORDER = [
    ("AGENTS.md", "Work Instructions (AGENTS)", "shared"),
    ("AGENTSOUL.md", "Agent Soul (AGENTSOUL)", "shared"),
]

_HEADER = """\
# BaoBao Assistant

> This file is auto-generated by BaoBaoClaude. Do not edit manually.
> Last updated: {timestamp}
"""


class ClaudeMdAssembler:
    """Reads shared persona files, assembles CLAUDE.md."""

    def __init__(
        self,
        shared_dir: Path,
        workspace_dir: Path,
        locale: str = "en-US",
        allowed_users: frozenset[int] | None = None,
    ) -> None:
        self.shared_dir = shared_dir
        self.workspace_dir = workspace_dir
        self.locale = locale
        self.allowed_users = allowed_users
        self.output_path = workspace_dir / "CLAUDE.md"
        self._source_mtimes: dict[str, float] = {}

    def _read_file(self, path: Path) -> str:
        """Read a file, stripping frontmatter, returning empty string if missing."""
        try:
            content = path.read_text(encoding="utf-8").strip()
            return strip_frontmatter(content).strip()
        except OSError:
            return ""

    def _resolve_source_dir(self, source: str) -> Path:
        """Return shared_dir or workspace_dir based on source tag."""
        return self.shared_dir if source == "shared" else self.workspace_dir

    def _experience_listing(self) -> str:
        """Generate a listing of memory/experience/ topic files."""
        exp_dir = self.workspace_dir / "memory" / "experience"
        if not exp_dir.is_dir():
            return ""
        files = sorted(f.stem for f in exp_dir.glob("*.md"))
        if not files:
            return ""
        lines = ["### Experience Topics (Long-term Memory)\n"]
        for name in files:
            lines.append(f"- `{name}` → memory/experience/{name}.md")
        return "\n".join(lines)

    def _resolve_agentsoul_path(self) -> Path:
        """Return workspace-local AGENTSOUL.md if it exists, else shared."""
        local = self.workspace_dir / ".persona" / "AGENTSOUL.md"
        if local.is_file():
            return local
        return self.shared_dir / "AGENTSOUL.md"

    def _user_profiles_section(self) -> str:
        """Generate the embedded User Profiles section.

        For each allowed user, reads the resolved profile (workspace-local
        takes priority over shared) and formats it as a markdown subsection.
        """
        if not self.allowed_users:
            return ""

        from baobaobot.persona.profile import read_user_profile_raw_resolved

        users_dir = self.shared_dir / "users"
        parts: list[str] = []
        for uid in sorted(self.allowed_users):
            raw = read_user_profile_raw_resolved(
                users_dir, uid, workspace_dir=self.workspace_dir
            )
            if raw:
                parts.append(f"### User {uid}\n\n{raw}")

        if not parts:
            return ""
        return "\n\n".join(parts)

    def assemble(self) -> str:
        """Build the full CLAUDE.md content from source files."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        parts: list[str] = [_HEADER.format(timestamp=timestamp)]

        for filename, section_title, source in _SECTION_ORDER:
            if filename == "AGENTSOUL.md":
                filepath = self._resolve_agentsoul_path()
            else:
                source_dir = self._resolve_source_dir(source)
                filepath = source_dir / filename
            content = self._read_file(filepath)
            if content:
                parts.append(f"---\n\n## {section_title}")
                parts.append(content)

        # Dynamic memory context: list experience topic files
        exp_listing = self._experience_listing()
        if exp_listing:
            parts.append(f"---\n\n## Memory Context\n\n{exp_listing}")

        # Embedded user profiles
        profiles_section = self._user_profiles_section()
        if profiles_section:
            parts.append(f"---\n\n## User Profiles\n\n{profiles_section}")

        result = "\n\n".join(parts) + "\n"
        # Replace template variables (safety net for old AGENTS.md with {{BIN_DIR}})
        result = result.replace("{{BIN_DIR}}", str(self.shared_dir / "bin"))
        result = result.replace("{{USERS_DIR}}", str(self.shared_dir / "users"))
        result = result.replace("{{WORKSPACE_DIR}}", str(self.workspace_dir))
        result = result.replace("{{LOCALE}}", self.locale)

        # Inject workspace important instructions
        important_path = self.workspace_dir / ".persona" / "important.md"
        workspace_important = self._read_file(important_path) if important_path.exists() else ""
        result = result.replace(
            "{{WORKSPACE_IMPORTANT_INSTRUCTIONS}}",
            f"\n{workspace_important}" if workspace_important else "",
        )

        # Collapse runs of 3+ newlines to at most 2 (prevents blank-line artifacts from empty placeholders)
        import re
        result = re.sub(r"\n{3,}", "\n\n", result)
        return result

    def write(self) -> None:
        """Assemble and write CLAUDE.md to the workspace root."""
        content = self.assemble()
        self.output_path.write_text(content, encoding="utf-8")
        logger.info("Assembled CLAUDE.md at %s", self.output_path)

        # Clean up legacy BAOBAOBOT.md if present
        legacy = self.workspace_dir / "BAOBAOBOT.md"
        if legacy.exists():
            legacy.unlink()
            logger.info("Removed legacy BAOBAOBOT.md from %s", self.workspace_dir)

        # Update mtime cache
        self._update_mtimes()

    def _update_mtimes(self) -> None:
        """Cache modification times of source files, experience dir, and profiles."""
        self._source_mtimes = {}
        for filename, _, source in _SECTION_ORDER:
            if filename == "AGENTSOUL.md":
                # Track both local (.persona/) and shared paths
                local = self.workspace_dir / ".persona" / "AGENTSOUL.md"
                shared = self.shared_dir / "AGENTSOUL.md"
                if local.exists():
                    self._source_mtimes["local:AGENTSOUL.md"] = local.stat().st_mtime
                self._source_mtimes["local:AGENTSOUL.md:exists"] = (
                    1.0 if local.exists() else 0.0
                )
                if shared.exists():
                    self._source_mtimes["shared:AGENTSOUL.md"] = shared.stat().st_mtime
            else:
                source_dir = self._resolve_source_dir(source)
                filepath = source_dir / filename
                if filepath.exists():
                    self._source_mtimes[f"{source}:{filename}"] = (
                        filepath.stat().st_mtime
                    )

        # Track experience directory (mtime changes when files added/removed)
        exp_dir = self.workspace_dir / "memory" / "experience"
        if exp_dir.is_dir():
            self._source_mtimes["experience_dir"] = exp_dir.stat().st_mtime

        # Track workspace important instructions
        important_path = self.workspace_dir / ".persona" / "important.md"
        self._source_mtimes["local:important.md:exists"] = (
            1.0 if important_path.exists() else 0.0
        )
        if important_path.exists():
            self._source_mtimes["local:important.md"] = important_path.stat().st_mtime

        # Track user profile files (shared and workspace-local)
        if self.allowed_users:
            users_dir = self.shared_dir / "users"
            for uid in self.allowed_users:
                shared_p = users_dir / f"{uid}.md"
                local_p = self.workspace_dir / ".persona" / f"{uid}.md"
                if shared_p.exists():
                    self._source_mtimes[f"shared:profile:{uid}"] = (
                        shared_p.stat().st_mtime
                    )
                if local_p.exists():
                    self._source_mtimes[f"local:profile:{uid}"] = (
                        local_p.stat().st_mtime
                    )
                self._source_mtimes[f"local:profile:{uid}:exists"] = (
                    1.0 if local_p.exists() else 0.0
                )

    def needs_rebuild(self) -> bool:
        """Check if any source file, experience dir, or profile has changed."""
        if not self.output_path.exists():
            return True

        if not self._source_mtimes:
            # No cached mtimes — need rebuild
            return True

        for filename, _, source in _SECTION_ORDER:
            if filename == "AGENTSOUL.md":
                local = self.workspace_dir / ".persona" / "AGENTSOUL.md"
                shared = self.shared_dir / "AGENTSOUL.md"
                local_exists = local.exists()
                cached_exists = (
                    self._source_mtimes.get("local:AGENTSOUL.md:exists", 0.0) == 1.0
                )

                # Local created or deleted → rebuild
                if local_exists != cached_exists:
                    return True

                if local_exists:
                    # Local is authoritative — only check local mtime
                    current = local.stat().st_mtime
                    cached = self._source_mtimes.get("local:AGENTSOUL.md", 0)
                    if current > cached:
                        return True
                else:
                    # No local — check shared
                    if shared.exists():
                        current = shared.stat().st_mtime
                        cached = self._source_mtimes.get("shared:AGENTSOUL.md", 0)
                        if current > cached:
                            return True
            else:
                source_dir = self._resolve_source_dir(source)
                filepath = source_dir / filename
                if filepath.exists():
                    current_mtime = filepath.stat().st_mtime
                    cached = self._source_mtimes.get(f"{source}:{filename}", 0)
                    if current_mtime > cached:
                        return True

        # Check workspace important instructions
        important_path = self.workspace_dir / ".persona" / "important.md"
        important_exists = important_path.exists()
        cached_important_exists = (
            self._source_mtimes.get("local:important.md:exists", 0.0) == 1.0
        )
        if important_exists != cached_important_exists:
            return True
        if important_exists:
            current = important_path.stat().st_mtime
            cached = self._source_mtimes.get("local:important.md", 0)
            if current > cached:
                return True

        # Check experience directory for added/removed files
        exp_dir = self.workspace_dir / "memory" / "experience"
        if exp_dir.is_dir():
            current_mtime = exp_dir.stat().st_mtime
            cached = self._source_mtimes.get("experience_dir", 0)
            if current_mtime > cached:
                return True

        # Check user profile files for changes
        if self.allowed_users:
            users_dir = self.shared_dir / "users"
            for uid in self.allowed_users:
                shared_p = users_dir / f"{uid}.md"
                local_p = self.workspace_dir / ".persona" / f"{uid}.md"

                # Local profile created or deleted → rebuild
                local_exists = local_p.exists()
                cached_exists = (
                    self._source_mtimes.get(f"local:profile:{uid}:exists", 0.0) == 1.0
                )
                if local_exists != cached_exists:
                    return True

                # Check local profile mtime
                if local_exists:
                    current = local_p.stat().st_mtime
                    cached = self._source_mtimes.get(f"local:profile:{uid}", 0)
                    if current > cached:
                        return True

                # Check shared profile mtime
                if shared_p.exists():
                    current = shared_p.stat().st_mtime
                    cached = self._source_mtimes.get(f"shared:profile:{uid}", 0)
                    if current > cached:
                        return True

        return False


def rebuild_all_workspaces(
    shared_dir: Path,
    workspace_dirs: list[Path],
    locale: str = "en-US",
    allowed_users: frozenset[int] | None = None,
) -> int:
    """Rebuild CLAUDE.md for all workspaces where sources have changed.

    Returns the number of workspaces rebuilt.
    """
    rebuilt = 0
    for ws in workspace_dirs:
        assembler = ClaudeMdAssembler(
            shared_dir, ws, locale=locale, allowed_users=allowed_users
        )
        if assembler.needs_rebuild():
            assembler.write()
            rebuilt += 1
    return rebuilt

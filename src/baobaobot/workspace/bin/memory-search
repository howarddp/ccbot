#!/usr/bin/env python3
"""Search BaoBao memories via SQLite index (FTS5 + vector + tag filtering).

Usage:
    memory-search <query> [--days N] [--tag TAG] [--mode MODE] [--workspace PATH]

Modes:
    hybrid   — Both FTS5 + vector merged via RRF (default, recommended)
    keyword  — FTS5 only (line-level results)
    vector   — Embedding cosine similarity only (paragraph-level, debug use)

When embedding is unavailable (no API key or openai package), hybrid/vector
automatically fall back to keyword mode. The effective mode is shown in output.

Examples:
    memory-search "architecture"
    memory-search "tmux" --days 7
    memory-search "login" --tag decision
    memory-search "開心"
"""

import argparse
import sys
from pathlib import Path

# Allow importing _memory_common from the same directory
sys.path.insert(0, str(Path(__file__).resolve().parent))
from _memory_common import (
    connect_db,
    format_file_label,
    resolve_workspace,
    search,
    sync_workspace,
)


def main() -> None:
    parser = argparse.ArgumentParser(description="Search BaoBao memories")
    parser.add_argument("query", help="Search query string")
    parser.add_argument("--days", type=int, default=None, help="Limit to last N days")
    parser.add_argument(
        "--tag", type=str, default=None, help="Filter by tag (without # prefix)"
    )
    parser.add_argument(
        "--mode",
        type=str,
        default="hybrid",
        choices=["keyword", "vector", "hybrid"],
        help="Search mode (default: hybrid)",
    )
    parser.add_argument("--workspace", type=str, default=None, help="Workspace path")
    args = parser.parse_args()

    workspace = resolve_workspace(args.workspace)
    if not workspace.exists():
        print(f"Workspace not found: {workspace}", file=sys.stderr)
        sys.exit(1)

    conn = connect_db(workspace)
    sync_workspace(conn, workspace)

    results, effective_mode = search(conn, args.query, args.days, args.tag, mode=args.mode)

    if not results:
        msg = f"No results for: {args.query}"
        if args.tag:
            msg += f" (tag: #{args.tag})"
        if effective_mode != args.mode:
            msg += f" (fallback: {args.mode} → {effective_mode})"
        print(msg)
        conn.close()
        sys.exit(0)

    # Detect if results are paragraph-level (have 'heading' key)
    is_paragraph = bool(results and "heading" in results[0])

    current_file = None
    for r in results:
        heading = r.get("heading", "")
        heading_suffix = f" [{heading}]" if heading else ""
        file_label = format_file_label(r) + heading_suffix

        if is_paragraph:
            # Paragraph-level output: show full paragraph content
            if file_label != current_file:
                current_file = file_label
                print(f"\n\U0001f4c4 {file_label}")
            # Indent each line of the paragraph
            for line in r["content"].splitlines():
                print(f"  {line}")
        else:
            # Line-level output (keyword mode, backward-compatible)
            label_no_heading = format_file_label(r)
            if label_no_heading != current_file:
                current_file = label_no_heading
                print(f"\n\U0001f4c4 {label_no_heading}")
            print(f"  L{r['line_num']}: {r['content']}")

    # Also search attachment descriptions
    att_results = conn.execute(
        "SELECT memory_path, description, file_path, file_type "
        "FROM attachment_meta WHERE description LIKE ?",
        (f"%{args.query}%",),
    ).fetchall()

    if att_results:
        print(f"\n\U0001f4ce Attachments:")
        for r in att_results:
            icon = "\U0001f5bc" if r["file_type"] == "image" else "\U0001f4c4"
            print(f"  {icon} {r['description']} \u2192 {r['file_path']}")
            print(f"     (in {r['memory_path']})")

    total = len(results) + len(att_results)
    suffix = f" [tag: #{args.tag}]" if args.tag else ""
    if effective_mode != args.mode:
        mode_label = f" mode={args.mode}→{effective_mode}"
    elif args.mode != "hybrid":
        mode_label = f" mode={effective_mode}"
    else:
        mode_label = ""
    print(f"\n({total} matches{suffix}{mode_label})")
    conn.close()


if __name__ == "__main__":
    main()
